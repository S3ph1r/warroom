{
  "BGSAXO|HOLDINGS|e646560d6d34": {
    "code": "import pandas as pd\nimport re\n\ndef parse_italian_date(date_str):\n    \"\"\"\n    Converte una stringa data in formato italiano (es. \"19-dic-2025\") in formato \"YYYY-MM-DD\".\n    \"\"\"\n    italian_months = {'gen':'01','feb':'02','mar':'03','apr':'04','mag':'05','giu':'06',\n                      'lug':'07','ago':'08','set':'09','ott':'10','nov':'11','dic':'12'}\n    match = re.match(r'(\\d{1,2})-([a-zA-Z]{3})-(\\d{4})', date_str)\n    if match:\n        day, month, year = match.groups()\n        month_num = italian_months.get(month.lower(), '01')\n        return f\"{year}-{month_num}-{day.zfill(2)}\"\n    return None\n\ndef clean_number(val):\n    \"\"\"\n    Pulizia e conversione di stringhe numeriche in float, gestendo formati europei\n    (virgola come separatore decimale, punto come separatore delle migliaia)\n    e valori non numerici/vuoti.\n    \"\"\"\n    if pd.isna(val) or str(val).strip() == '':\n        return 0.0\n    s = str(val).replace('.', '').replace(',', '.').replace('%', '').strip()\n    try:\n        return float(s)\n    except ValueError:\n        return 0.0\n\ndef parse(file_path: str) -> list[dict]:\n\n    # --- Funzione ausiliaria per leggere il CSV in modo robusto ---\n    def _read_csv_robust(path, header_val=None, nrows_val=None):\n        separators = [';', ',', '\\t'] # Prova separatori comuni in ordine di probabilit\u00e0 per CSV europei\n        encodings = ['utf-8', 'latin1', 'cp1252'] # Prova encoding comuni\n\n        for sep in separators:\n            for enc in encodings:\n                try:\n                    # Usiamo engine='python' per una maggiore tolleranza agli errori di formattazione\n                    # e on_bad_lines='warn' per non interrompere il parsing alla prima riga malformata.\n                    df_temp = pd.read_csv(\n                        path,\n                        sep=sep,\n                        engine='python',\n                        header=header_val,\n                        nrows=nrows_val,\n                        encoding=enc,\n                        on_bad_lines='warn' # Avvisa di righe malformate invece di generare un errore\n                    )\n                    # Verifica che il DataFrame non sia vuoto e abbia un numero ragionevole di colonne\n                    # Questo aiuta a scartare tentativi di lettura con un separatore completamente errato\n                    if not df_temp.empty and df_temp.shape[1] > 1:\n                        return df_temp\n                except (UnicodeDecodeError, pd.errors.ParserError, ValueError) as e:\n                    # In caso di errore di decodifica o parsing, prova la prossima combinazione\n                    continue\n        \n        # Se tutte le combinazioni falliscono, solleva un errore\n        raise pd.errors.ParserError(f\"Impossibile leggere il file CSV '{path}' con qualsiasi separatore o encoding testato.\")\n\n\n    # --- 1. Trova la riga di intestazione dinamicamente ---\n    # Leggi le prime righe del CSV senza intestazione usando la funzione robusta.\n    df_raw = _read_csv_robust(file_path, header_val=None, nrows_val=20)\n\n    header_row_index = 0\n    # Indicatori comuni per la riga di intestazione. Aggiunto 'Tipo' per robustezza.\n    possible_header_indicators = [\"Strumento\", \"Ticker\", \"Simbolo\", \"Quantit\u00e0\", \"ISIN\", \"Valuta\", \"Tipo\"]\n    \n    for i, row in df_raw.iterrows():\n        # Pulisci i valori della riga per una migliore corrispondenza\n        cleaned_row_values = [str(cell).strip().strip('\"') for cell in row.values]\n        \n        # Cerca qualsiasi indicatore di intestazione nella riga\n        if any(indicator.lower() in val.lower() for val in cleaned_row_values for indicator in possible_header_indicators):\n            header_row_index = i\n            break\n            \n    # --- 2. Rileggi il CSV con l'intestazione identificata ---\n    # Usa la funzione robusta per leggere l'intero file con l'intestazione corretta.\n    df = _read_csv_robust(file_path, header_val=header_row_index)\n    \n    # --- 3. Pulisci i nomi delle colonne ---\n    df.columns = [c.strip().strip('\"') for c in df.columns]\n    \n    # --- 4. Mappa i nomi delle colonne italiane ai nomi dello schema target ---\n    COL_MAPPING = {\n        'name': ['Strumento', 'Descrizione', 'Nome'],\n        'ticker': ['Simbolo', 'Ticker', 'Codice'],\n        'isin': ['ISIN'],\n        'quantity': ['Quantit\u00e0', 'Qty'],\n        'currency': ['Valuta', 'Currency'],\n        'current_price': ['Prz. corrente', 'Prezzo corrente', 'Ultimo prezzo'],\n        'purchase_price': ['Prezzo di apertura', 'Prezzo acquisto'],\n        'current_value': ['Valore', 'Controvalore', 'Esposizione', 'Valore di mercato (EUR)', 'Valore di mercato'],\n        'asset_type': ['Tipo', 'Asset class', 'Categoria attivit\u00e0']\n    }\n\n    # Trova le colonne effettive nel DataFrame basandoti sulla mappatura\n    actual_cols = {}\n    for target_col, possible_names in COL_MAPPING.items():\n        for name in possible_names:\n            if name in df.columns:\n                actual_cols[target_col] = name\n                break\n    \n    results = []\n    # --- 5. Filtra ed elabora le righe ---\n    for _, row in df.iterrows():\n        # Estrai il nome dello strumento per il filtraggio\n        row_name = str(row.get(actual_cols.get('name'), '')).strip()\n        \n        # Filtra le righe vuote o di riepilogo\n        # Una riga \u00e8 considerata valida se ha un nome non vuoto E\n        # la quantit\u00e0 o il valore corrente sono diversi da zero.\n        # Inoltre, filtra le righe dove il nome assomiglia a un totale di categoria (es. \"Azioni (48)\")\n        if not row_name or re.search(r'\\(.*\\d+\\)', row_name):\n            continue\n        \n        # Estrai e pulisci i dati per lo schema target\n        holding = {}\n        \n        # Nome\n        holding['name'] = row_name\n\n        # ISIN\n        holding['isin'] = str(row.get(actual_cols.get('isin'), '')).strip()\n\n        # Quantit\u00e0\n        holding['quantity'] = clean_number(row.get(actual_cols.get('quantity'), 0))\n\n        # Valuta (default 'EUR' se non trovata o vuota)\n        holding['currency'] = str(row.get(actual_cols.get('currency'), 'EUR')).strip().upper()\n        if not holding['currency']:\n            holding['currency'] = 'EUR'\n\n        # Prezzo corrente (opzionale)\n        holding['current_price'] = clean_number(row.get(actual_cols.get('current_price'), ''))\n        # Se il prezzo \u00e8 0.0 e la colonna non era presente, impostalo a None\n        if holding['current_price'] == 0.0 and 'current_price' not in actual_cols:\n             holding['current_price'] = None\n\n        # Valore corrente\n        holding['current_value'] = clean_number(row.get(actual_cols.get('current_value'), 0))\n\n        # Filtra ulteriormente se sia quantit\u00e0 che valore corrente sono zero\n        if holding['quantity'] == 0 and holding['current_value'] == 0:\n            continue\n\n        # Tipo di asset (default 'STOCK')\n        asset_type_raw = str(row.get(actual_cols.get('asset_type'), '')).strip().upper()\n        if 'AZIONE' in asset_type_raw:\n            holding['asset_type'] = 'STOCK'\n        elif 'ETF' in asset_type_raw:\n            holding['asset_type'] = 'ETF'\n        elif 'BOND' in asset_type_raw or 'OBBLIGAZION' in asset_type_raw:\n            holding['asset_type'] = 'BOND'\n        elif 'FUND' in asset_type_raw or 'FONDO' in asset_type_raw:\n            holding['asset_type'] = 'FUND'\n        else:\n            holding['asset_type'] = 'STOCK' # Default se non specificato o riconosciuto\n\n        # Logica di estrazione del Ticker\n        holding['ticker'] = ''\n        if 'ticker' in actual_cols and str(row.get(actual_cols['ticker'], '')).strip():\n            holding['ticker'] = str(row[actual_cols['ticker']]).strip()\n            # Pulisci i suffissi comuni del ticker (es. ':xnas', ':xmil')\n            holding['ticker'] = re.sub(r':x[a-z]+$', '', holding['ticker'], flags=re.IGNORECASE)\n        \n        if not holding['ticker'] and holding['name']:\n            # Prova a estrarre sequenze di lettere maiuscole dal nome (es. \"Apple Inc.\" -> \"AAPL\")\n            # Cerca sequenze di 2-5 lettere maiuscole che non siano parole comuni come \"Inc\" o \"Ltd\"\n            potential_tickers = re.findall(r'\\b[A-Z]{2,5}\\b', holding['name'])\n            # Filtra parole comuni che potrebbero non essere ticker\n            common_non_tickers = {'INC', 'LTD', 'CORP', 'HLDGS', 'ADR', 'SA', 'AS', 'NV', 'AG'}\n            filtered_tickers = [t for t in potential_tickers if t.upper() not in common_non_tickers]\n            \n            if filtered_tickers:\n                # Prioritizza i ticker pi\u00f9 corti o pi\u00f9 distintivi\n                filtered_tickers.sort(key=len)\n                holding['ticker'] = filtered_tickers[0]\n            \n        if not holding['ticker'] and holding['isin']:\n            # Fallback all'ISIN se non \u00e8 stato trovato alcun ticker\n            holding['ticker'] = holding['isin']\n\n        results.append(holding)\n    \n    return results",
    "created_at": "2025-12-29T10:48:13.915311",
    "success_count": 2,
    "last_error": null
  },
  "BGSAXO|TRANSACTIONS|73f3dfd5ce23": {
    "code": "import pdfplumber\nimport re\n\ndef parse_italian_date(date_str: str) -> str | None:\n    \"\"\"\n    Converts an Italian date string (e.g., \"19-dic-2025\") to \"YYYY-MM-DD\" format.\n    \"\"\"\n    italian_months = {\n        'gen': '01', 'feb': '02', 'mar': '03', 'apr': '04', 'mag': '05', 'giu': '06',\n        'lug': '07', 'ago': '08', 'set': '09', 'ott': '10', 'nov': '11', 'dic': '12'\n    }\n    match = re.match(r'(\\d{1,2})-([a-zA-Z]{3})-(\\d{4})', date_str)\n    if match:\n        day, month, year = match.groups()\n        month_num = italian_months.get(month.lower(), '01')\n        return f\"{year}-{month_num}-{day.zfill(2)}\"\n    return None\n\ndef clean_number(text: str | None) -> float:\n    \"\"\"\n    Cleans and converts a European number string (e.g., \"1.170,68\", \"-0,85EUR\") to a float.\n    Handles empty strings or non-convertible text by returning 0.0.\n    \"\"\"\n    if not text:\n        return 0.0\n    t = str(text).strip()\n    # Replace dots used as thousands separators, then commas used as decimal separators\n    t = t.replace('.', '').replace(',', '.')\n    # Remove any non-numeric characters except for a leading hyphen\n    t = re.sub(r'[^\\d.-]', '', t)\n    try:\n        return float(t)\n    except ValueError:\n        return 0.0\n\ndef parse(file_path: str) -> list[dict]:\n    \"\"\"\n    Parses a financial PDF to extract transaction details.\n\n    Args:\n        file_path: The path to the PDF file.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents a transaction.\n        Each transaction dictionary has the following schema:\n        - date: str (YYYY-MM-DD)\n        - ticker: str\n        - isin: str (optional, None if not found)\n        - operation: str (BUY, SELL, DIVIDEND)\n        - quantity: float\n        - price: float\n        - total_amount: float\n        - currency: str (e.g., EUR, USD, CAD - defaults to EUR)\n        - fees: float (default 0.0, sum of all fees)\n    \"\"\"\n    transactions = []\n    current_date = None\n    last_parsed_transaction = None # Used to associate multi-line details (like fees, ISIN)\n\n    # Regex patterns\n    date_pattern = re.compile(r'(\\d{1,2}-[a-zA-Z]{3}-\\d{4})')\n    \n    # Pattern for \"Contrattazione\" (Buy/Sell) transactions\n    # Captures: Ticker (1), Operation (Acquista/Vendi) (2), Quantity (3), Price (4), PriceCurrency (5), \n    # and optional TotalAmount (Importocontabilizzato) if on the same line (6).\n    contrattazione_pattern = re.compile(\n        r'Contrattazione\\s+(.+?)\\s+'          # Group 1: Ticker\n        r'(Acquista|Vendi)'                    # Group 2: Operation\n        r'(?:(-?\\d+)?@([\\d.,]+)(USD|EUR|CAD)?)?' # Optional: Group 3: Qty, Group 4: Price, Group 5: PriceCurrency\n        r'(?:\\s+([\\d.,-]+))?'                  # Optional: Group 6: TotalAmount (Importocontabilizzato)\n        r'\\s*.*'                               # Consume rest of line (e.g., \"Pending -\")\n    )\n\n    # Pattern for \"Operazionesulcapitale\" (Dividend) transactions\n    # Captures: Ticker (1), TotalAmount (Importocontabilizzato) (2)\n    dividend_pattern = re.compile(\n        r'Operazionesulcapitale\\s+(.+?)\\s+'   # Group 1: Ticker\n        r'Dividendoincontanti\\s+([\\d.,-]+)\\s*.*' # Group 2: TotalAmount (Importocontabilizzato)\n    )\n\n    # Pattern for Total Amount on a subsequent line (e.g., \"18-dic-2025 -1.170,68 1.362,01\" or \"256,83 -\")\n    # This extracts the first number that looks like the 'Importocontabilizzato'.\n    total_amount_sub_line_pattern = re.compile(\n        r'^(?:\\d{1,2}-[a-zA-Z]{3}-\\d{4}\\s+)?' # Optional date prefix\n        r'([\\d.,-]+)'                         # Group 1: The main amount\n        r'(?:\\s+[\\d.,-]+)?'                   # Optional: a second amount (like for cash balance)\n        r'\\s*[-]?\\s*$'                        # Optional trailing hyphen and whitespace\n    )\n\n    # Pattern for \"Commissione\" (Fee) lines\n    # Captures: FeeAmount (1), optional FeeCurrency (2)\n    commissione_pattern = re.compile(r'Commissione.*?([\\d.,-]+)(EUR|USD|CAD)?')\n    \n    # Pattern for ISIN\n    isin_pattern = re.compile(r'ISIN\\s+([A-Z]{2}[A-Z0-9]{9}[0-9])')\n\n    # Pattern for Dividend Quantity and Price (e.g., '2 0,89USD')\n    # Captures: Quantity (1), Price (2), PriceCurrency (3)\n    dividend_qty_price_pattern = re.compile(r'(\\d+)\\s+([\\d.,]+)(USD|EUR|CAD)')\n\n    with pdfplumber.open(file_path) as pdf:\n        for page in pdf.pages:\n            text = page.extract_text()\n            lines = text.split('\\n')\n\n            i = 0\n            while i < len(lines):\n                line = lines[i].strip()\n                i += 1\n                if not line:\n                    continue\n\n                # 1. Date Detection (Group header for transactions)\n                date_match = date_pattern.search(line)\n                if date_match:\n                    current_date = parse_italian_date(date_match.group(1))\n                    last_parsed_transaction = None # Reset for new date group of transactions\n                    continue\n\n                # Skip lines until a date is established\n                if not current_date:\n                    continue\n\n                new_transaction = None\n\n                # 2. Try to parse a \"Contrattazione\" (Buy/Sell) transaction\n                contrattazione_match = contrattazione_pattern.match(line)\n                if contrattazione_match:\n                    ticker = contrattazione_match.group(1).strip()\n                    operation_raw = contrattazione_match.group(2)\n                    quantity_str = contrattazione_match.group(3)\n                    price_str = contrattazione_match.group(4)\n                    # price_currency_str = contrattazione_match.group(5) # Not used in output schema for 'currency'\n                    total_amount_str_on_line = contrattazione_match.group(6)\n\n                    operation = 'BUY' if operation_raw == 'Acquista' else 'SELL'\n                    \n                    quantity = clean_number(quantity_str) if quantity_str else 0.0\n                    if operation == 'SELL' and quantity > 0: # Ensure sell quantity is negative\n                        quantity *= -1\n\n                    price = clean_number(price_str) if price_str else 0.0\n                    # Assume total_amount is in EUR, as it's the reporting currency and often not explicitly stated.\n                    total_amount = clean_number(total_amount_str_on_line) if total_amount_str_on_line else 0.0\n\n                    new_transaction = {\n                        'date': current_date,\n                        'ticker': ticker,\n                        'isin': None,\n                        'operation': operation,\n                        'quantity': quantity,\n                        'price': price,\n                        'total_amount': total_amount,\n                        'currency': 'EUR', \n                        'fees': 0.0\n                    }\n\n                    # Look ahead in subsequent lines for missing total_amount, fees, ISIN\n                    look_ahead_idx = i\n                    while look_ahead_idx < len(lines) and look_ahead_idx < i + 5: # Look up to 5 lines ahead\n                        sub_line = lines[look_ahead_idx].strip()\n                        look_ahead_idx += 1\n\n                        if new_transaction['total_amount'] == 0.0: # If total_amount not yet set\n                            total_amount_match = total_amount_sub_line_pattern.match(sub_line)\n                            if total_amount_match:\n                                new_transaction['total_amount'] = clean_number(total_amount_match.group(1))\n\n                        commissione_match = commissione_pattern.search(sub_line)\n                        if commissione_match:\n                            fee_amount = clean_number(commissione_match.group(1))\n                            new_transaction['fees'] += fee_amount\n\n                        isin_match = isin_pattern.search(sub_line)\n                        if isin_match and new_transaction['isin'] is None:\n                            new_transaction['isin'] = isin_match.group(1).strip()\n                    \n                    transactions.append(new_transaction)\n                    last_parsed_transaction = new_transaction # Set for potential future detached fee lines\n                    continue # Move to the next main line in the document\n\n                # 3. Try to parse an \"Operazionesulcapitale\" (Dividend) transaction\n                dividend_match = dividend_pattern.match(line)\n                if dividend_match:\n                    ticker = dividend_match.group(1).strip()\n                    total_amount_str = dividend_match.group(2)\n\n                    # Assume total_amount is in EUR\n                    new_transaction = {\n                        'date': current_date,\n                        'ticker': ticker,\n                        'isin': None,\n                        'operation': 'DIVIDEND',\n                        'quantity': 0.0, # Will try to find this in next lines\n                        'price': 0.0,    # Will try to find this in next lines\n                        'total_amount': clean_number(total_amount_str),\n                        'currency': 'EUR', \n                        'fees': 0.0\n                    }\n\n                    # Look ahead for ISIN, quantity, price, fees\n                    look_ahead_idx = i\n                    while look_ahead_idx < len(lines) and look_ahead_idx < i + 5: # Look up to 5 lines ahead\n                        sub_line = lines[look_ahead_idx].strip()\n                        look_ahead_idx += 1\n\n                        isin_match = isin_pattern.search(sub_line)\n                        if isin_match and new_transaction['isin'] is None:\n                            new_transaction['isin'] = isin_match.group(1).strip()\n                        \n                        commissione_match = commissione_pattern.search(sub_line)\n                        if commissione_match:\n                            fee_amount = clean_number(commissione_match.group(1))\n                            new_transaction['fees'] += fee_amount\n\n                        # Check for dividend quantity/price line (e.g., '2 0,89USD')\n                        if new_transaction['quantity'] == 0.0 and new_transaction['price'] == 0.0:\n                            qty_price_match = dividend_qty_price_pattern.match(sub_line)\n                            if qty_price_match:\n                                new_transaction['quantity'] = clean_number(qty_price_match.group(1))\n                                new_transaction['price'] = clean_number(qty_price_match.group(2))\n                                # The price currency is for the price, not necessarily the total_amount currency\n                                # new_transaction['currency'] = qty_price_match.group(3) \n                    \n                    transactions.append(new_transaction)\n                    last_parsed_transaction = new_transaction\n                    continue # Move to the next main line in the document\n\n                # 4. Handle multi-line details (fees/ISIN) that might appear on lines not immediately\n                # following a transaction start, but belong to the *last parsed transaction*.\n                if last_parsed_transaction:\n                    commissione_match = commissione_pattern.search(line)\n                    if commissione_match:\n                        fee_amount = clean_number(commissione_match.group(1))\n                        last_parsed_transaction['fees'] += fee_amount\n                        continue # This line was a fee, move on\n\n                    isin_match = isin_pattern.search(line)\n                    if isin_match and last_parsed_transaction['isin'] is None:\n                        last_parsed_transaction['isin'] = isin_match.group(1).strip()\n                        continue # This line was an ISIN, move on\n                    \n                    # Also dividend qty/price might be in a line by itself, though less common\n                    if last_parsed_transaction['operation'] == 'DIVIDEND' and \\\n                       last_parsed_transaction['quantity'] == 0.0 and \\\n                       last_parsed_transaction['price'] == 0.0:\n                        qty_price_match = dividend_qty_price_pattern.match(line)\n                        if qty_price_match:\n                            last_parsed_transaction['quantity'] = clean_number(qty_price_match.group(1))\n                            last_parsed_transaction['price'] = clean_number(qty_price_match.group(2))\n                            # new_transaction['currency'] = qty_price_match.group(3) # See above comment\n                            continue\n\n    return transactions",
    "created_at": "2025-12-29T10:49:49.796674",
    "success_count": 2,
    "last_error": null
  },
  "BG_SAXO|TRANSACTIONS|73f3dfd5ce23": {
    "code": "import pdfplumber\nimport re\n\n# Provided helper functions with correction for 'ott'\ndef parse_italian_date(date_str):\n    italian_months = {\n        'gen': '01', 'feb': '02', 'mar': '03', 'apr': '04', 'mag': '05', 'giu': '06',\n        'lug': '07', 'ago': '08', 'set': '09', 'ott': '10', 'nov': '11', 'dic': '12'\n    }\n    match = re.match(r'(\\d{1,2})-([a-zA-Z]{3})-(\\d{4})', date_str)\n    if match:\n        day, month, year = match.groups()\n        month_num = italian_months.get(month.lower(), '01') # Default to '01' if month not found\n        return f\"{year}-{month_num}-{day.zfill(2)}\"\n    return None\n\ndef clean_number(text):\n    if not text: return 0.0\n    t = str(text).replace('.', '').replace(',', '.').strip()\n    t = re.sub(r'[^\\d.-]', '', t) # Remove non-numeric chars except . and -\n    try: return float(t)\n    except ValueError: return 0.0\n\ndef parse(file_path: str) -> list[dict]:\n    transactions = []\n    current_date = None\n    last_transaction = None # Stores the dictionary of the last transaction being built\n\n    # Regex patterns\n    date_pattern = re.compile(r'(\\d{1,2}-[a-zA-Z]{3}-\\d{4})')\n\n    # Pattern to match the main transaction line (Contrattazione/Operazionesulcapitale)\n    # It attempts to capture:\n    # 1. Event Type (Contrattazione|Operazionesulcapitale)\n    # 2. Product Name\n    # 3. Operation (Acquista|Vendi|Dividendoincontanti)\n    # 4. Quantity/Price details (e.g., '2@301,93', '1@155,29USD')\n    # 5. Optional: Importocontabilizzato (amount) and a trailing dash/cash value\n    transaction_main_line_pattern = re.compile(\n        r'^(Contrattazione|Operazionesulcapitale)\\s+' # Group 1: Event Type\n        r'(.*?)\\s+'                                  # Group 2: Product Name\n        r'(Acquista|Vendi|Dividendoincontanti)'      # Group 3: Operation\n        r'(.*?)(?:\\s+(-?[\\d.,]+)\\s*(-|[\\d.,]+))?$'   # Group 4: Operation details, Group 5: Amount, Group 6: Cash/dash\n    )\n\n    # Patterns for multi-line details\n    commission_pattern = re.compile(r'^Commissione\\s+.*?(-?[\\d.,]+)(EUR|USD|CAD)?')\n    costo_totale_pattern = re.compile(r'Costototale\\s+(-?[\\d.,]+)(EUR|USD|CAD)?')\n    isin_pattern = re.compile(r'[A-Z]{2}[A-Z0-9]{9}[0-9]') # Standard ISIN format\n    quantity_price_pattern = re.compile(r'(Acquista|Vendi)\\s*(-?\\d+)?@([\\d.,]+)(USD|EUR|CAD)?')\n    dividend_per_share_pattern = re.compile(r'Dividendoperazione\\s+([\\d.,]+)(USD|EUR|CAD)?')\n    dividend_quantity_pattern = re.compile(r'Quantit\u00e0idonea\\s+(\\d+)')\n\n\n    with pdfplumber.open(file_path) as pdf:\n        for page in pdf.pages:\n            text = page.extract_text()\n            if not text:\n                continue\n\n            lines = text.split('\\n')\n            for line in lines:\n                line = line.strip()\n                if not line:\n                    continue\n\n                # 1. Check for Date Header\n                date_match = date_pattern.search(line)\n                if date_match:\n                    current_date = parse_italian_date(date_match.group(1))\n                    # Reset last_transaction state when a new date header is found\n                    last_transaction = None\n                    continue\n\n                # 2. Check for Transaction Start\n                tx_match = transaction_main_line_pattern.match(line)\n                if tx_match:\n                    # Skip transactions explicitly marked as \"Pending\"\n                    if \"Pending\" in line:\n                        last_transaction = None # Reset last transaction state\n                        continue\n\n                    event_type = tx_match.group(1)\n                    product_name = tx_match.group(2).strip()\n                    operation_raw = tx_match.group(3).strip()\n                    # op_details_raw = tx_match.group(4).strip() # Contains \"2@301,93\" or empty for dividend, not directly used\n                    amount_str = tx_match.group(5) # Importocontabilizzato\n                    # cash_str = tx_match.group(6) # Not used in output schema\n\n                    # Initialize new transaction dictionary\n                    new_tx = {\n                        'date': current_date,\n                        'ticker': product_name,\n                        'isin': None,\n                        'operation': None,\n                        'quantity': 0.0,\n                        'price': 0.0,\n                        'total_amount': clean_number(amount_str) if amount_str else 0.0,\n                        'currency': 'EUR', # Default currency\n                        'fees': 0.0\n                    }\n\n                    # Determine operation type and parse quantity/price/currency\n                    if operation_raw == 'Acquista':\n                        new_tx['operation'] = 'BUY'\n                        qp_match = quantity_price_pattern.search(line)\n                        if qp_match:\n                            new_tx['quantity'] = clean_number(qp_match.group(2)) if qp_match.group(2) else 1.0\n                            new_tx['price'] = clean_number(qp_match.group(3))\n                            new_tx['currency'] = qp_match.group(4) or new_tx['currency']\n                    elif operation_raw == 'Vendi':\n                        new_tx['operation'] = 'SELL'\n                        qp_match = quantity_price_pattern.search(line)\n                        if qp_match:\n                            new_tx['quantity'] = abs(clean_number(qp_match.group(2))) if qp_match.group(2) else 1.0\n                            new_tx['price'] = clean_number(qp_match.group(3))\n                            new_tx['currency'] = qp_match.group(4) or new_tx['currency']\n                    elif operation_raw == 'Dividendoincontanti':\n                        new_tx['operation'] = 'DIVIDEND'\n                        # Dividend per share might be in the main line or a subsequent line\n                        dividend_op_match = dividend_per_share_pattern.search(line)\n                        if dividend_op_match:\n                            new_tx['price'] = clean_number(dividend_op_match.group(1))\n                            new_tx['currency'] = dividend_op_match.group(2) or new_tx['currency']\n                        # Quantity will be picked up from \"Quantit\u00e0idonea\" if present in a subsequent line.\n\n                    # Add new transaction to the list and set as the current transaction being built\n                    transactions.append(new_tx)\n                    last_transaction = new_tx\n                    continue # Continue to next line, which might contain more details for this transaction\n\n                # 3. Handle Multi-row Transaction Details (if a transaction is currently being built)\n                if last_transaction:\n                    # Commission fees\n                    comm_match = commission_pattern.search(line)\n                    if comm_match:\n                        last_transaction['fees'] += clean_number(comm_match.group(1))\n                        last_transaction['currency'] = comm_match.group(2) or last_transaction['currency']\n                        continue\n\n                    # Costototale (Total Amount) - This value should override the initial Importocontabilizzato\n                    costo_match = costo_totale_pattern.search(line)\n                    if costo_match:\n                        last_transaction['total_amount'] = clean_number(costo_match.group(1))\n                        last_transaction['currency'] = costo_match.group(2) or last_transaction['currency']\n                        continue\n\n                    # ISIN\n                    isin_match = isin_pattern.search(line)\n                    if isin_match:\n                        last_transaction['isin'] = isin_match.group(0)\n                        continue\n\n                    # Specific dividend details (quantity and price per share)\n                    if last_transaction['operation'] == 'DIVIDEND':\n                        qty_match = dividend_quantity_pattern.search(line)\n                        if qty_match:\n                            last_transaction['quantity'] = clean_number(qty_match.group(1))\n                            continue\n                        # If Dividendoperazione not found on main line, try finding it here\n                        dividend_op_match = dividend_per_share_pattern.search(line)\n                        if dividend_op_match:\n                            last_transaction['price'] = clean_number(dividend_op_match.group(1))\n                            last_transaction['currency'] = dividend_op_match.group(2) or last_transaction['currency']\n                            continue\n\n    return transactions",
    "created_at": "2025-12-29T22:16:36.575045",
    "success_count": 0,
    "last_error": null
  }
}